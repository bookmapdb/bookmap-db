<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BookMap β€” λ„μ„ κ΄€κ³„λ„</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    .filter-btn {
      padding: 6px 12px;
      border: 1px solid #ccc;
      border-radius: 20px;
      margin: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    .filter-btn:hover {
      background-color: #f0f0f0;
    }
    .filter-btn.active {
      background-color: #2563eb;
      color: white;
      border-color: #2563eb;
    }
  </style>
</head>
<body class="bg-gray-50 text-gray-800">

  <!-- μƒλ‹¨ λ„¤λΉ„κ²μ΄μ… -->
  <header class="bg-blue-600 text-white shadow">
    <div class="max-w-6xl mx-auto px-6 py-4 flex justify-between items-center">
      <h1 class="text-xl font-bold">π“ BookMap</h1>
      <nav class="flex gap-6 text-sm">
        <a href="index.html" class="hover:underline">ν™</a>
        <a href="form.html" class="hover:underline">λ„μ„ λ“±λ΅</a>
        <a href="book.html" class="hover:underline">λ¶λ§µ λ¦¬μ¤νΈ</a>
        <a href="map.html" class="hover:underline font-bold">λ¶λ§µ λ³΄κΈ°</a>
      </nav>
    </div>
  </header>

  <!-- λ©”μΈ -->
  <main class="max-w-6xl mx-auto px-6 py-10">
    <h2 class="text-2xl font-bold mb-4">π“– λ„μ„ κ΄€κ³„λ„</h2>
    <p class="mb-6">
      λ¶λ§µ κ΄€κ³„λ„λ” λ„μ„, μ €μ, μ£Όμ , λ‹¨κ³„ λ“±κ³Ό κ°™μ€ κ΄€κ³„μ— λ”°λΌ μ—°κ²°λλ” κ²ƒμ„ λ³΄μ—¬μ¤λ‹λ‹¤. 
      λ„μ„λ…μ΄λ‚ μ €μ μ΄λ¦„μ— λ§μ°μ¤λ¥Ό μ¬λ¦¬λ©΄ κ°„λ‹¨ν• μ„¤λ…μ„ λ³Ό μ μμΌλ©°, ν΄λ¦­ν•μ‹λ©΄ ν•΄λ‹Ή λ„μ„ μƒμ„Ένμ΄μ§€λ΅ μ΄λ™ν•©λ‹λ‹¤.
    </p>

    <!-- ν•„ν„° -->
    <div id="filters" class="bg-white p-4 rounded shadow mb-4 space-y-3">
      <div>
        <strong>μΉ΄ν…κ³ λ¦¬</strong><br>
        <div id="filter-category"></div>
      </div>
      <div>
        <strong>λ‹¨κ³„</strong><br>
        <div id="filter-level"></div>
      </div>
      <div>
        <strong>λ„μ„κµ¬λ¶„</strong><br>
        <div id="filter-division"></div>
      </div>
      <div>
        <strong>μ €μ</strong><br>
        <div id="filter-author"></div>
      </div>
      <div>
        <strong>μ£Όμ </strong><br>
        <div id="filter-subject"></div>
      </div>
    </div>

    <!-- λ…Έλ“ μƒ‰μƒ μ•λ‚΄ -->
    <div class="bg-white p-4 rounded shadow mb-4 flex flex-wrap gap-6 items-center">
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="#333"></circle></svg> ν° μ£Όμ </div>
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="brown"></circle></svg> μ„Έλ¶€ μ£Όμ </div>
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="blue"></circle></svg> μ €μ</div>
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="orange"></circle></svg> μΉ΄ν…κ³ λ¦¬</div>
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="green"></circle></svg> λ„μ„κµ¬λ¶„</div>
      <div><svg width="16" height="16"><circle cx="8" cy="8" r="6" fill="gray"></circle></svg> λ„μ„</div>
    </div>

    <!-- κ·Έλν”„ -->
    <div class="bg-white p-4 rounded shadow">
      <svg id="graph" width="100%" height="600"></svg>
    </div>
  </main>

  <script>
    const nodeColors = {
      theme: "#333",
      subject: "brown",
      author: "blue",
      category: "orange",
      division: "green",
      book: "gray"
    };

    async function loadGraph() {
      const res = await fetch("books.json");
      const books = await res.json();

      // nodes / links
      const nodes = [];
      const links = [];
      const nodeMap = new Map();

      function addNode(id, type) {
        if (!nodeMap.has(id)) {
          const node = { id, type };
          nodeMap.set(id, node);
          nodes.push(node);
        }
        return nodeMap.get(id);
      }

      books.forEach(book => {
        const bookNode = addNode(book.title, "book");
        if (book.author) {
          const a = addNode(book.author, "author");
          links.push({ source: bookNode.id, target: a.id });
        }
        if (book.theme) {
          const t = addNode(book.theme, "theme");
          links.push({ source: bookNode.id, target: t.id });
        }
        if (book.category) {
          book.category.split(",").map(s=>s.trim()).forEach(c=>{
            const cat = addNode(c,"category");
            links.push({ source: bookNode.id, target: cat.id });
          });
        }
        if (book.division) {
          const d = addNode(book.division, "division");
          links.push({ source: bookNode.id, target: d.id });
        }
        if (book.subject) {
          (Array.isArray(book.subject)?book.subject:book.subject.split(",")).forEach(s=>{
            const sub = addNode(s.trim(),"subject");
            links.push({ source: bookNode.id, target: sub.id });
          });
        }
      });

      const svg = d3.select("#graph");
      const width = svg.node().getBoundingClientRect().width;
      const height = +svg.attr("height");

      const g = svg.append("g");

      // μ¤ μ μ©
      svg.call(d3.zoom().on("zoom", (event) => {
        g.attr("transform", event.transform);
      }));

      const link = g.append("g")
        .attr("stroke", "#ccc")
        .selectAll("line")
        .data(links)
        .enter().append("line");

      const node = g.append("g")
        .selectAll("circle")
        .data(nodes)
        .enter().append("circle")
        .attr("r", 8)
        .attr("fill", d => nodeColors[d.type] || "gray")
        .call(drag(simulation));

      const label = g.append("g")
        .selectAll("text")
        .data(nodes)
        .enter().append("text")
        .text(d => d.id)
        .attr("font-size", "10px")
        .attr("dy", -10)
        .attr("fill", "black");

      const simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links).id(d => d.id).distance(120))
        .force("charge", d3.forceManyBody().strength(-300))
        .force("center", d3.forceCenter(width / 2, height / 2));

      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);

        label
          .attr("x", d => d.x)
          .attr("y", d => d.y);
      });

      function drag(simulation) {
        return d3.drag()
          .on("start", (event, d) => {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          })
          .on("drag", (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
          })
          .on("end", (event, d) => {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          });
      }
    }

    loadGraph();
  </script>
</body>
</html>
